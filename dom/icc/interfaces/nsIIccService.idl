/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "nsISupports.idl"

interface nsICursorContinueCallback;
interface nsIDOMMozIccInfo;

[scriptable, uuid(c343d213-8c2b-4d19-83a6-de3b37aa5672)]
interface nsIIccCallback : nsISupports
{
  const short RETRY_COUNT_UNSPECIFIED = -1;

  void notifySuccess();

  /**
   * @param error
   *        Either nsIRilCallback::SUCCESS, or nsIRilCallback::ERROR_*.
   */
  void notifyError(in unsigned long error);

  /**
   * @param lockType
   *        A nsIIccServcie::CARD_LOCK_TYPE_*.
   * @param enabled
   *        True if card lock of specified type has been enabled. False
   *        otherwise.
   *
   * @see WebIDL IccGetCardLockResult.
   */
  void notifyGetCardLockStateSuccess(in unsigned long lockType,
                                     in boolean enabled);

  /**
   * @param lockType
   *        A nsIIccServcie::CARD_LOCK_TYPE_*.
   *
   * @see WebIDL IccUnlockCardLockResult/IccSetCardLockResult.
   */
  void notifySetCardLockSuccess(in unsigned long lockType);

  /**
   * @param lockType
   *        A nsIIccServcie::CARD_LOCK_TYPE_*.
   * @param error
   *        See |notifyError| for possible values.
   * @param retryCount
   *        Remaining retries before getting locked. RETRY_COUNT_UNSPECIFIED if
   *        not available.
   *
   * @see WebIDL IccCardLockError.
   */
  void notifySetCardLockError(in unsigned long lockType,
                              in unsigned long error,
                              in short retryCount);

  /**
   * @param lockType
   *        A nsIIccServcie::CARD_LOCK_TYPE_*.
   * @param retryCount
   *        Remaining retries before getting locked.
   *
   * @see WebIDL IccGetCardLockRetryCountResult.
   */
  void notifyGetCardLockRetryCountSuccess(in unsigned long lockType,
                                          in short retryCount);

  void notifyContactSuccess(in AString id,
                            [array, size_is(nameCount)] in wstring names,
                            in uint32_t nameCount,
                            [array, size_is(telCount)] in wstring tels,
                            in uint32_t telCount,
                            [array, size_is(emailCount)] in wstring emails,
                            in uint32_t emailCount);

  /**
   * @param channel
   *        An integer channel id.
   */
  void notifyOpenChannelSuccess(in long channel);

  void notifyExchangeAPDUSuccess(in long sw1,
                                 in long sw2,
                                 in AString response);

  /**
   * @param match
   *        True if the result of a matchMvno call is positive. False otherwise.
   */
  void notifyMatchMvnoSuccess(in boolean match);
};

[scriptable, uuid(7c0ada3d-d8d4-493e-9243-fa3df39855e4)]
interface nsIIccListener : nsISupports
{
  void notifyStkCommand(in DOMString aMessage);
  void notifyStkSessionEnd();
  void notifyCardStateChanged();
  void notifyIccInfoChanged();
};

/**
 * XPCOM component (in the content process) that provides the ICC information.
 */
[scriptable, uuid(a336f9dc-7a77-426b-9781-20d11051af78)]
interface nsIIccService : nsISupports
{
  // MUST match enum IccCardState in MozIcc.webidl!
  const unsigned long CARD_STATE_UNKNOWN = 0;
  const unsigned long CARD_STATE_READY = 1;
  const unsigned long CARD_STATE_PIN_REQUIRED = 2;
  const unsigned long CARD_STATE_PUK_REQUIRED = 3;
  const unsigned long CARD_STATE_PERMANENT_BLOCKED = 4;
  const unsigned long CARD_STATE_PERSONALIZATION_IN_PROGRESS = 5;
  const unsigned long CARD_STATE_PERSONALIZATION_READY = 6;
  const unsigned long CARD_STATE_NETWORK_LOCKED = 7;
  const unsigned long CARD_STATE_NETWORK_SUBSET_LOCKED = 8;
  const unsigned long CARD_STATE_CORPORATE_LOCKED = 9;
  const unsigned long CARD_STATE_SERVICE_PROVIDER_LOCKED = 10;
  const unsigned long CARD_STATE_SIM_LOCKED = 11;
  const unsigned long CARD_STATE_NETWORK_PUK_REQUIRED = 12;
  const unsigned long CARD_STATE_NETWORK_SUBSET_PUK_REQUIRED = 13;
  const unsigned long CARD_STATE_CORPORATE_PUK_REQUIRED = 14;
  const unsigned long CARD_STATE_SERVICE_PROVIDER_PUK_REQUIRED = 15;
  const unsigned long CARD_STATE_SIM_PUK_REQUIRED = 16;
  const unsigned long CARD_STATE_NETWORK1_LOCKED = 17;
  const unsigned long CARD_STATE_NETWORK2_LOCKED = 18;
  const unsigned long CARD_STATE_HRPD_NETWORK_LOCKED = 19;
  const unsigned long CARD_STATE_RUIM_CORPORATE_LOCKED = 20;
  const unsigned long CARD_STATE_RUIM_SERVICE_PROVIDER_LOCKED = 21;
  const unsigned long CARD_STATE_RUIM_LOCKED = 22;
  const unsigned long CARD_STATE_NETWORK1_PUK_REQUIRED = 23;
  const unsigned long CARD_STATE_NETWORK2_PUK_REQUIRED = 24;
  const unsigned long CARD_STATE_HRPD_NETWORK_PUK_REQUIRED = 25;
  const unsigned long CARD_STATE_RUIM_CORPORATE_PUK_REQUIRED = 26;
  const unsigned long CARD_STATE_RUIM_SERVICE_PROVIDER_PUK_REQUIRED = 27;
  const unsigned long CARD_STATE_RUIM_PUK_REQUIRED = 28;
  const unsigned long CARD_STATE_ILLEGAL = 29;

  const unsigned long CARD_STATE_UNDETECTED = 4294967295; // UINT32_MAX

  const unsigned long MVNO_TYPE_IMSI = 0;
  const unsigned long MVNO_TYPE_SPN = 1;
  const unsigned long MVNO_TYPE_GID = 2;

  // MUST match enum IccContactType in MozIcc.webidl!
  const unsigned long CONTACT_TYPE_ADN = 0;
  const unsigned long CONTACT_TYPE_FDN = 1;
  const unsigned long CONTACT_TYPE_SDN = 2;

  // Union of card lock enum types in MozIcc.webidl
  const unsigned long CARD_LOCK_TYPE_PIN = 0;
  const unsigned long CARD_LOCK_TYPE_PIN2 = 1;
  const unsigned long CARD_LOCK_TYPE_PUK = 2;
  const unsigned long CARD_LOCK_TYPE_PUK2 = 3;
  const unsigned long CARD_LOCK_TYPE_NCK = 4;
  const unsigned long CARD_LOCK_TYPE_NCK1 = 5;
  const unsigned long CARD_LOCK_TYPE_NCK2 = 6;
  const unsigned long CARD_LOCK_TYPE_HNCK = 7;
  const unsigned long CARD_LOCK_TYPE_CCK = 8;
  const unsigned long CARD_LOCK_TYPE_SPCK = 9;
  const unsigned long CARD_LOCK_TYPE_RCCK = 10;
  const unsigned long CARD_LOCK_TYPE_RSPCK = 11;
  const unsigned long CARD_LOCK_TYPE_NCK_PUK = 12;
  const unsigned long CARD_LOCK_TYPE_NCK1_PUK = 13;
  const unsigned long CARD_LOCK_TYPE_NCK2_PUK = 14;
  const unsigned long CARD_LOCK_TYPE_HNCK_PUK = 15;
  const unsigned long CARD_LOCK_TYPE_CCK_PUK = 16;
  const unsigned long CARD_LOCK_TYPE_SPCK_PUK = 17;
  const unsigned long CARD_LOCK_TYPE_RCCK_PUK = 18;
  const unsigned long CARD_LOCK_TYPE_RSPCK_PUK = 19;
  const unsigned long CARD_LOCK_TYPE_FDN = 20;

  /**
   * Called when a content process registers receiving unsolicited messages from
   * RadioInterfaceLayer in the chrome process. Only a content process that has
   * the 'mobileconnection' permission is allowed to register.
   */
  void registerIccMsg(in unsigned long clientId, in nsIIccListener listener);
  void unregisterIccMsg(in unsigned long clientId, in nsIIccListener listener);

  /**
   * UICC Information
   */
  nsIDOMMozIccInfo getIccInfo(in unsigned long clientId);

  /**
   * Card State
   */
  unsigned long getCardState(in unsigned long clientId);

  /**
   * STK interfaces.
   */
  void sendStkResponse(in unsigned long clientId,
                       in jsval command,
                       in jsval response);
  void sendStkMenuSelection(in unsigned long clientId,
                            in unsigned short itemIdentifier,
                            in boolean helpRequested);
  void sendStkTimerExpiration(in unsigned long clientId,
                              in octet timerId,
                              in unsigned long timerValue);
  void sendStkEventDownload(in unsigned long clientId,
                            in jsval event);

  /**
   * Card lock interfaces.
   */

  /**
   * When error occurred, |nsIIccCallback.notifyError| is called. Otherwise,
   * |nsIIccCallback.notifyGetCardLockStateSuccess|.
   */
  void getCardLockState(in unsigned long clientId,
                        in nsIIccCallback callback,
                        in unsigned long lockType,
                        [optional] in AString aid);

  /**
   * When error occurred, |nsIIccCallback.notifySetCardLockError| is called.
   * Otherwise, |nsIIccCallback.notifySetCardLockSuccess|.
   */
  void unlockCardLock(in unsigned long clientId,
                      in nsIIccCallback callback,
                      in unsigned long lockType,
                      in AString password,
                      in AString newPassword,
                      [optional] in AString aid);

  /**
   * When error occurred, |nsIIccCallback.notifySetCardLockError| is called.
   * Otherwise, |nsIIccCallback.notifySetCardLockSuccess|.
   */
  void enableCardLock(in unsigned long clientId,
                      in nsIIccCallback callback,
                      in unsigned long lockType,
                      in AString password,
                      in bool enabled,
                      [optional] in AString aid);

  /**
   * When error occurred, |nsIIccCallback.notifySetCardLockError| is called.
   * Otherwise, |nsIIccCallback.notifySetCardLockSuccess|.
   */
  void changeCardLockPassword(in unsigned long clientId,
                              in nsIIccCallback callback,
                              in unsigned long lockType,
                              in AString password,
                              in AString newPassword,
                              [optional] in AString aid);

  /**
   * When error occurred, |nsIIccCallback.notifyError| is called.
   * Otherwise, |nsIIccCallback.notifyGetCardLockRetryCountSuccess|.
   */
  void getCardLockRetryCount(in unsigned long clientId,
                             in nsIIccCallback callback,
                             in unsigned long lockType);

  /**
   * Phonebook interfaces.
   */

  /**
   * This method provides cursor based access to ICC contacts.
   *
   * The client first calls this method with a valid nsIIccCallback implementing
   * callback, and this method returns a nsICursorContinueCallback for further
   * retrieval.
   *
   * |readContacts| will at least call to some member functions of that passed
   * callback once. When no more contact available, it calls to
   * |nsIIccCallback.notifySuccess| indicating session ended. When some error
   * occurs, it calls to |nsIIccCallback.notifyError| and terminates the session
   * as well. Otherwise, it calls to |nsIIccCallback.notifyContactSuccess| with
   * the first ICC contact read.
   *
   * The client MAY only call |nsICursorContinueCallback.handleContinue| once
   * after a |nsIIccCallback.notifyContactSuccess| call, and only after
   * |nsIIccCallback.notifyContactSuccess| is called will the back end start
   * reading the next one and hence call to
   * |nsIIccCallback.notifyContactSuccess| again.
   */
  nsICursorContinueCallback readContacts(in unsigned long clientId,
                                         in nsIIccCallback callback,
                                         in unsigned long contactType);

  /**
   * When error occurred, |nsIIccCallback.notifyError| is called.
   * Otherwise, |nsIIccCallback.notifyContactSuccess|.
   */
  void updateContact(in unsigned long clientId,
                     in nsIIccCallback callback,
                     in unsigned long contactType,
                     in AString id,
                     [array, size_is(nameCount)] in wstring names,
                     in uint32_t nameCount,
                     [array, size_is(telCount)] in wstring tels,
                     in uint32_t telCount,
                     [array, size_is(emailCount)] in wstring emails,
                     in uint32_t emailCount,
                     in DOMString pin2);

  /**
   * Secure Card Icc communication channel
   */

  /**
   * When error occurred, |nsIIccCallback.notifyError| is called.
   * Otherwise, |nsIIccCallback.notifyOpenChannelSuccess|.
   */
  void iccOpenChannel(in unsigned long clientId,
                      in nsIIccCallback callback,
                      in DOMString aid);

  /**
   * When error occurred, |nsIIccCallback.notifyError| is called.
   * Otherwise, |nsIIccCallback.notifyExchangeAPDUSuccess|.
   */
  void iccExchangeAPDU(in unsigned long clientId,
                       in nsIIccCallback callback,
                       in long channel,
                       in long cla,
                       in long command,
                       in AString path,
                       in long p1,
                       in long p2,
                       in long p3,
                       in AString data,
                       in AString data2);

  /**
   * When error occurred, |nsIIccCallback.notifyError| is called.
   * Otherwise, |nsIIccCallback.notifySuccess|.
   */
  void iccCloseChannel(in unsigned long clientId,
                       in nsIIccCallback callback,
                       in long channel);

  /**
   * When error occurred, |nsIIccCallback.notifyError| is called.
   * Otherwise, |nsIIccCallback.notifyMatchMvnoSuccess|.
   */
  void matchMvno(in unsigned long clientId,
                 in nsIIccCallback callback,
                 in unsigned long mvnoType,
                 in DOMString mvnoData);
};
